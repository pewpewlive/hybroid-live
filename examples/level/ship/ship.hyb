env ShipEntity as Level

use Pewpew
use Utils

const DASH_DURATION = 12
const INPUT_TIME = 10
const MIN_REQUIRED_CHANGE = 0.4f

pub class Ship {
   entity id
  Camera cam = new Camera()

  number dashTime
  number onDashTime
  bool doDash
  fixed dashAngle = -1f
  number coolDown
  entity coolDownMesh

  number inputTimer = INPUT_TIME
  bool firstInputDone
  bool firstInputReleased
  bool initialRelease

  new(fixed x, y) {
    id = NewShip(x, y, 0)
    coolDownMesh = NewEntity(x, y)
    let playerConfig = struct{
      shield = 5,
      camera_distance = -50f,
      camera_rotation_x_axis = -15d,
      move_joystick_color = 0xffffffff
    }

    ConfigurePlayer(0, playerConfig)

    ConfigureShipWeapon(id, struct{
      cannon = CannonType.Double,
      frequency = CannonFreq.Freq10,
    })

    let _, md, _, _ = GetPlayerInputs(0)
    
    tick {
      if !IsEntityAlive(id) return
      if !doDash {
        DashUpdate()
      }
      if doDash {
        OnDash()
      }
      cam.Update(id)
    }
  }

  fn DashUpdate() {
    coolDown -= 1
    if coolDown >= 0 {
      let px, py = GetEntityPosition(id)
      AddRotationToEntityMesh(coolDownMesh, 11d, 0f, 0f, 1f)
      SetEntityPosition(coolDownMesh, px, py)
      SetEntityMesh(coolDownMesh, DashCooldownMesh, 0)
      return
    } else if IsEntityAlive(coolDownMesh) {
      DestroyEntity(coolDownMesh)
    }

    let ma, md, _, _ = GetPlayerInputs(0)

    inputTimer -= 1
    if inputTimer <= 0 {
      inputTimer = 0
    }
    if md == 0f and !initialRelease {
      Print("Initial Release")
      initialRelease = true
    }

    if md > 0.5f and !firstInputDone and inputTimer == 0 and initialRelease {
      Print("First input done")
      firstInputDone = true
      inputTimer = INPUT_TIME
      dashAngle = ma
    }
    if inputTimer == 0 and firstInputDone {
      Print("Too late after first input")
      firstInputDone = false
      firstInputReleased = false
      initialRelease = false
      return
    }

    if md == 0f and inputTimer != 0 and !firstInputReleased and firstInputDone {
      Print("First input released")
      firstInputReleased = true
    }

    if firstInputReleased and inputTimer != 0 and md > 0.5f and firstInputDone {
      if Fmath:AbsFixed(dashAngle-ma) > 20d {
        Print("Dash Fail!")
        firstInputDone = false
        firstInputReleased = false
        initialRelease = false
        inputTimer = 0
        dashAngle = -1fx
        return
      }
      Print("Dash!")
      doDash = true
      firstInputReleased = false
      initialRelease = false
      firstInputDone = false
      inputTimer = 0
      MakeShipTransparent(id, DASH_DURATION + 15)
    }
  }

  fn OnDash() {
    onDashTime += 1
    SetShipSpeed(id, 0f, 0f, DASH_DURATION)
    let px, py = GetEntityPosition(id)
    let sin, cos = Fmath:Sincos(dashAngle)

    let entities = GetEntitiesInRadius(px, py, 10f)
    for _, v in entities {
      if v == id continue

      EntityReactToWeapon(v, struct{
        type = WeaponType.AtomizeExplosion,
        x = px,
        y = py,
        player_index = 0
      })
    }

    let minSpeed = 10f
    let maxSpeed = 35f
    let t = 2.71f ^ (Fmath:FromFraction(onDashTime, DASH_DURATION) ^ 5f)
    let speed = FmathHelpers:Clamp(t * maxSpeed, minSpeed, maxSpeed)
    EntityMove(id, cos*speed, sin*speed)
    
    repeat 10f with i {
      let angle = (i - 1fx) * 2fx * Fmath:Tau() / 2fx / 10fx
      let pdy, pdx = Fmath:Sincos(angle)

      AddParticle(px, py, 0f,
        pdx * Fmath:RandomFixed(0.5f, 3f),
        pdy * Fmath:RandomFixed(0.5f, 3f),
        0f,
        0xffff00ff,
        10
      )
    }

    if onDashTime >= DASH_DURATION {
      onDashTime = 0
      doDash = false
      coolDown = 20
      coolDownMesh = NewEntity(px, py)
      SpawnEntity(coolDownMesh, 0)
      SetEntityPositionInterpolation(coolDownMesh, true)
      SetEntityAngleInterpolation(coolDownMesh, true)
      SetShipSpeed(id, 1f, 0f, -1)
    }
  }
}

pub Ship SHIP = new Ship(Globals:WIDTH / 2f, Globals:HEIGHT / 2f)