env ShipEntity as Level

use Pewpew
use Utils

const DASH_DURATION = 10
const INPUT_TIME = 6

pub class Ship {
  let entity id
  let Camera cam = new Camera()

  number dashTime
  number onDashTime
  bool doDash
  fixed dashAngle = -1f
  number coolDown
  entity coolDownMesh

  number inputTimer = INPUT_TIME
  bool firstInputDone
  bool firstInputReleased
  fixed previousDist
  fixed change

  new(fixed x, y) {
    id = NewShip(x, y, 0)
    coolDownMesh = NewEntity(x, y)
    let playerConfig = struct{
      shield = 5,
      camera_distance = -50f,
      camera_rotation_x_axis = -15d,
      move_joystick_color = 0xffffffff
    }

    ConfigurePlayer(0, playerConfig)

    ConfigureShipWeapon(id, struct{
      cannon = CannonType.Double,
      frequency = CannonFreq.Freq10,
    })

    let _, md, _, _ = GetPlayerInputs(0)
    self.previousDist = md
    
    tick {
      if !doDash {
        DashUpdate()
      }
      if doDash {
        OnDash()
      }
      cam.Update(id)
    }
  }

  fn DashUpdate() {
    coolDown -= 1
    if coolDown >= 0 {
      let px, py = GetEntityPosition(id)
      AddRotationToEntityMesh(coolDownMesh, 11d, 0f, 0f, 1f)
      SetEntityPosition(coolDownMesh, px, py)
      SetEntityMesh(coolDownMesh, DashCooldownMesh, 0)
      return
    }else if IsEntityAlive(coolDownMesh) {
      DestroyEntity(coolDownMesh)
    }
    let ma, md, _, _ = GetPlayerInputs(0)
    let hardChange = Fmath:AbsFixed(md-previousDist)
    change = FmathHelpers:Lerp(change, hardChange, 0.3f)
    ConfigurePlayerHud(0, struct{
      top_left_line = ToString(change)
    })
    previousDist = md

    inputTimer -= 1
    if inputTimer <= 0 {
      inputTimer = 0
    }

    if md > 0.5f and !firstInputDone and inputTimer == 0 {
      firstInputDone = true
      inputTimer = INPUT_TIME
      dashAngle = ma
    }
    if !firstInputDone {
      return
    }

    if md < 0.5f and inputTimer == 0  {
      firstInputDone = false
      return
    }

    if md < 0.5f and inputTimer != 0 and !firstInputReleased  {
      firstInputReleased = true
    }

    if md < 0.5f and inputTimer == 0 and firstInputReleased {
      firstInputDone = false
      firstInputReleased = false
    }

    if firstInputReleased and inputTimer != 0 and md > 0.5f and hardChange > 0f {
      Print("Ma: ".. ToString(ma) .. " | Angle: " .. ToString(dashAngle) .. " | " .. ToString(30d))
      if Fmath:AbsFixed(dashAngle-ma) > 5d {
        firstInputDone = false
        firstInputReleased = false
        inputTimer = 0
        Print("here")
        dashAngle = -1fx
        return
      }
      doDash = true
      firstInputReleased = false
      firstInputDone = false
      inputTimer = 0
      MakeShipTransparent(id, DASH_DURATION)
    }
  }

  fn OnDash() {
    onDashTime += 1
    SetShipSpeed(id, 0f, 0f, -1)
    let px, py = GetEntityPosition(id)
    let sin, cos = Fmath:Sincos(dashAngle)

    let entities = GetEntitiesInRadius(px, py, 10f)
    for _, v in entities {
      if v == id continue

      EntityReactToWeapon(v, struct{
        type = WeaponType.AtomizeExplosion,
        x = cos*35f,
        y = sin*35f,
        player_index = 0
      })
    }
    
    EntityMove(id, cos*35f, sin*35f)
    
    repeat 10f with i {
      let angle = (i - 1fx) * 2fx * Fmath:Tau() / 2fx / 10fx
      let pdy, pdx = Fmath:Sincos(angle)

      AddParticle(px, py, 0f,
        pdx * Fmath:RandomFixed(0.5f, 3f),
        pdy * Fmath:RandomFixed(0.5f, 3f),
        0f,
        0xffff00ff,
        10
      )
    }

    if onDashTime >= DASH_DURATION {
      onDashTime = 0
      doDash = false
      coolDown = 20
      coolDownMesh = NewEntity(px, py)
      SpawnEntity(coolDownMesh, 0)
      SetEntityPositionInterpolation(coolDownMesh, true)
      SetEntityAngleInterpolation(coolDownMesh, true)
      SetShipSpeed(id, 1f, 2f, -1)
    }
  }
}

pub Ship SHIP = new Ship(Globals:WIDTH / 2f, Globals:HEIGHT / 2f)