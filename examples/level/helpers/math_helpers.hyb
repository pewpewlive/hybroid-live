env MathHelpers as Shared

use Math

pub fn Clamp(number n, min, max) -> number {
    if n < min {
        return min
    }
    if n > max {
        return max
    }

    return n
}

pub fn Wrap(number n, min, max) -> number {
    while n > max {
        n -= max
    }
    while n < min {
        n += max
    }
    //Pewpew:Print("Wrapped: "..n)
    return n
}

pub fn Lerp(number a, b, t) -> number {
    return a+(b-a)*t
}

pub fn InvLerp(number a, b, v) -> number 
    => Wrap((v-a)/(b-a), 0, 1)

pub fn Remap(number a, b, c, d, v) -> number {
    let t = InvLerp(c, d, v)
    return Lerp(a, b, t)
}

enum ParamType {
    Squared,
    Rooted,
    Linear
}

alias Parameter = struct{number x, y, ParamType pt}
alias Parameters = list<Parameter>

pub SineWave = [
    struct{
        x = 0, y = 0, 
        pt = ParamType.Linear
    },
    struct{
        x = 0.25, y = 0.5, 
        pt = ParamType.Linear
    },
    struct{
        x = 0.5, y = 1, 
        pt = ParamType.Rooted
    },
    struct{
        x = 0.75, y = 0.5,
        pt = ParamType.Rooted
    },
    struct{
        x = 1, y = 0,
        pt = ParamType.Linear
    }
]

pub fn ParametricInvLerp(number a, b, v, Parameters parameters) -> number {
    let linearT = InvLerp(a, b, v)

    for i, v in parameters {
        if i == 1 
            continue
        
        if linearT <= v.x {
            linearT = Lerp(parameters[i-1].y, v.y, InvLerp(parameters[i-1].x, v.x, linearT))
            linearT = match v.pt {
                ParamType.Squared => yield linearT*linearT
                ParamType.Rooted => yield Sqrt(linearT)
                else => yield linearT
            }
            break
        }
    }    

    return linearT
}